#### 原型链继承

```js
function Parent(){
  this.name = 'zhangsan';
  this.arr = [1,2,3];
}

function Child(){
  this.type='Child'
}

Child.prototype = new Parent();
const child = new Child();
const child1 = new Child();
console.log(child.arr,'arr'); // [1,2,3]
console.log(child1.arr,'arr'); // [1,2,3]
child1.arr.push(4)
console.log(child.arr,'arr'); // [1,2,3,4]
console.log(child1.arr,'arr'); // [1,2,3,4]
```

存在的问题：

- 所有实例共享同一个原型对象，它们的内存空间是共享的，当一个发生变化会影响到其他的

#### 构造函数继承（借助call）

```js
function Parent() {
  this.name = 'zhangsan';
  this.arr = [1, 2, 3];
}

Parent.prototype.getName = function () {
  return this.name;
}

function Child() {
  Parent.call(this);
  this.type = 'child'
}

const child = new Child();
console.log(child.name); // zhangsan
console.log(child);

const child1 = new Child();
child1.arr.push(4);
console.log(child.arr);
console.log(child1.arr);
console.log(child.getName()); // 报错 child.getName is not a function

```

存在的问题：

- 子类只能继承父类的实例属性和方法，不能继承原型属性和方法

#### 组合继承

```js
function Parent(name) {
  this.name = name;
  this.arr = [1, 2, 3];
}

Parent.prototype.getName = function () {
  return this.name
}

function Child(name) {
  Parent.call(this, name);
  this.type = 'Child'
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

const child = new Child('lisi');
const child1 = new Child('zhangsan');
console.log(child.name);
child1.arr.push(4);
console.log(child.arr);
console.log(child1.arr);
console.log(child.getName());
```

存在的问题：

- 父类会被多次调用

#### 原型式继承

```js
let parent = {
  name: 'zhangsan',
  arr: [1, 2, 3],
  getName: function () {
    console.log(this.name);
  }
}

const child = Object.create(parent);
child.getName();
const child1 = Object.create(parent);
child1.getName();
child1.arr.push(4);
console.log(child.arr);
console.log(child1.arr);
```

存在的问题：

- 多个实例的引用类型属性指向相同内存，存在篡改的可能

#### 寄生式继承

```js
let parent = {
  name: 'zhangsan',
  arr: [1, 2, 3],
  getName: function () {
    return this.arr
  }
}

function clone(origin) {
  let clone = Object.create(origin);
  clone.getArr = function () {
    return this.arr
  }
  return clone
}

let child = clone(parent)
console.log(child.name);
console.log(child.getName());
console.log(child.getArr());
```

存在的问题：

- 无法复用，每次都需要创建全新的函数实例
- 与构造函数无关，无法使用instanceof判断
- 不能传参

#### 寄生组合式继承

```js
function clone(parent, child) {
  child.prototype = Object.create(parent.prototype);
  child.prototype.constructor = child;
}

function Parent(){
  this.name = 'zhangsan';
  this.arr = [1,2,3];
}

Parent.prototype.getName = function(){
  return this.name;
}

function Child(){
  Parent.call(this);
  this.type = 'child'
}

clone(Parent,Child);

Child.prototype.getType = function(){
  return this.type
}

const child = new Child();
child.getName();
child.getType();
console.log(child.name); // zhangsan
console.log(child.arr); // [1, 2, 3]
const child1 = new Child();
child1.arr.push(4)
console.log(child.arr); // [1, 2, 3]
console.log(child1.arr); // [1, 2, 3, 4]
```

ES6中的extends关键字的底层逻辑采用的就是寄生组合式继承

#### new运算符

1. new运算符做了哪些事情？

```js
function Foo(){
  this.name = 'zhangsan'
};
const obj = new Foo()
```

- 创建一个空对象；
- 将创建的空对象的原型指向构造函数的原型；
- 执行构造函数并将this绑定到新对象上；
- 如果构造函数返回的是对象类型就直接返回，否则返回将绑定了this的新对象返回出来；

2. 手写new

```js
const myNew = function (fn, ...args) {
  const obj = Object.create(fn.prototype);
  const result = fn.apply(obj, args);
  return typeof result === 'object' && result !== null ? result : obj
}
function test() {
  this.name = 'zhangsan';
}
console.log(myNew(test));
```

3. new返回对象时有什么特性？

- 当用new调用构造函数时，如果内部使用return显示返回一个对象或者函数时，这个对象就会代替默认返回的实例对象，如果返回值是基本类型时会被忽略，就会返回默认的this实例，手动返回对象时不是new创建的实例，所以不会继承原构造函数的prototype，构造函数中所定义的属性和方法会被完全忽略，即this绑定丢失；

3. new返回基本值呢？

- 如果构造函数返回的是基本数据类型时会被忽略，最终返回new创建的实例对象，即this；

4. 为什么返回基本数据类型会被忽略？

- 因为new的设计目的就是生成一个实例对象，基本类型没有原型，js引擎判断返回值类型时，如果不是对象或者函数就返回this；

5. Object.create和new有什么区别？

- 是否执行构造函数：
  - Object.create不会执行任何构造函数；new会执行构造函数，并初始化属性；
- 原型设置方式：
  - Object.create直接设置传入的对象为原型；new会把构造函数的prototype设置为原型；
- 返回结果不同：
  - Object.create返回一个继承指定原型的空对象；new返回一个带初始化逻辑的实例对象
- constructor指向：
  - 用new创建的对象原型链上会自动有正确的constructor；Object.create不会自动设置；
- 应用场景不同：
  - Object.create适合做原型继承；new适合常规类实例化；

#### apply、call、bind





