#### 原型链继承

```js
function Parent(){
  this.name = 'zhangsan';
  this.arr = [1,2,3];
}

function Child(){
  this.type='Child'
}

Child.prototype = new Parent();
const child = new Child();
const child1 = new Child();
console.log(child.arr,'arr'); // [1,2,3]
console.log(child1.arr,'arr'); // [1,2,3]
child1.arr.push(4)
console.log(child.arr,'arr'); // [1,2,3,4]
console.log(child1.arr,'arr'); // [1,2,3,4]
```

存在的问题：

- 所有实例共享同一个原型对象，它们的内存空间是共享的，当一个发生变化会影响到其他的

#### 构造函数继承（借助call）

```js
function Parent() {
  this.name = 'zhangsan';
  this.arr = [1, 2, 3];
}

Parent.prototype.getName = function () {
  return this.name;
}

function Child() {
  Parent.call(this);
  this.type = 'child'
}

const child = new Child();
console.log(child.name); // zhangsan
console.log(child);

const child1 = new Child();
child1.arr.push(4);
console.log(child.arr);
console.log(child1.arr);
console.log(child.getName()); // 报错 child.getName is not a function

```

存在的问题：

- 子类只能继承父类的实例属性和方法，不能继承原型属性和方法

#### 组合继承

```js
function Parent(name) {
  this.name = name;
  this.arr = [1, 2, 3];
}

Parent.prototype.getName = function () {
  return this.name
}

function Child(name) {
  Parent.call(this, name);
  this.type = 'Child'
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

const child = new Child('lisi');
const child1 = new Child('zhangsan');
console.log(child.name);
child1.arr.push(4);
console.log(child.arr);
console.log(child1.arr);
console.log(child.getName());
```

存在的问题：

- 父类会被多次调用

#### 原型式继承

```js
let parent = {
  name: 'zhangsan',
  arr: [1, 2, 3],
  getName: function () {
    console.log(this.name);
  }
}

const child = Object.create(parent);
child.getName();
const child1 = Object.create(parent);
child1.getName();
child1.arr.push(4);
console.log(child.arr);
console.log(child1.arr);
```

存在的问题：

- 多个实例的引用类型属性指向相同内存，存在篡改的可能

#### 寄生式继承

```js
let parent = {
  name: 'zhangsan',
  arr: [1, 2, 3],
  getName: function () {
    return this.arr
  }
}

function clone(origin) {
  let clone = Object.create(origin);
  clone.getArr = function () {
    return this.arr
  }
  return clone
}

let child = clone(parent)
console.log(child.name);
console.log(child.getName());
console.log(child.getArr());
```

存在的问题：

- 无法复用，每次都需要创建全新的函数实例
- 与构造函数无关，无法使用instanceof判断
- 不能传参

#### 寄生组合式继承

```js
function clone(parent, child) {
  child.prototype = Object.create(parent.prototype);
  child.prototype.constructor = child;
}

function Parent(){
  this.name = 'zhangsan';
  this.arr = [1,2,3];
}

Parent.prototype.getName = function(){
  return this.name;
}

function Child(){
  Parent.call(this);
  this.type = 'child'
}

clone(Parent,Child);

Child.prototype.getType = function(){
  return this.type
}

const child = new Child();
child.getName();
child.getType();
console.log(child.name); // zhangsan
console.log(child.arr); // [1, 2, 3]
const child1 = new Child();
child1.arr.push(4)
console.log(child.arr); // [1, 2, 3]
console.log(child1.arr); // [1, 2, 3, 4]
```

ES6中的extends关键字的底层逻辑采用的就是寄生组合式继承





